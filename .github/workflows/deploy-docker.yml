name: Deploy to Docker

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      image_tag:
        description: 'Docker image tag'
        required: false
        default: 'latest'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v4
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=${{ github.event.inputs.image_tag }},enable=${{ github.event.inputs.image_tag != '' }}
          
    - name: Create optimized Dockerfile
      run: |
        cat > Dockerfile << 'DOCKER_EOF'
        # Build stage
        FROM node:18-alpine AS builder
        WORKDIR /app
        COPY package*.json ./
        RUN npm ci --only=production && npm cache clean --force
        
        # Runtime stage
        FROM node:18-alpine AS runtime
        
        # Install system dependencies
        RUN apk add --no-cache \
            git \
            python3 \
            make \
            g++ \
            && rm -rf /var/cache/apk/*
        
        # Create app directory
        WORKDIR /app
        
        # Copy dependencies from builder
        COPY --from=builder /app/node_modules ./node_modules
        
        # Copy application code
        COPY . .
        
        # Create non-root user
        RUN addgroup -g 1001 -S minecraft && \
            adduser -S minecraftbot -u 1001 -G minecraft && \
            chown -R minecraftbot:minecraft /app
        
        # Create config directory
        RUN mkdir -p /app/config && \
            mkdir -p /app/logs && \
            chown -R minecraftbot:minecraft /app/config /app/logs
        
        # Switch to non-root user
        USER minecraftbot
        
        # Expose port for web interface
        EXPOSE 3000 8080
        
        # Health check
        HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
          CMD node -e "console.log('Bot health check OK')" || exit 1
        
        # Environment variables
        ENV NODE_ENV=production
        ENV LOG_LEVEL=info
        
        # Default command
        CMD ["npm", "start"]
        DOCKER_EOF
        
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: Output image
      id: image
      run: echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}" >> $GITHUB_OUTPUT

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event.inputs.environment == 'staging' || github.event_name == 'workflow_dispatch'
    environment: staging
    
    steps:
    - name: Deploy to staging
      run: |
        echo "ðŸš€ Deploying to staging environment..."
        echo "Image: ${{ needs.build-and-push.outputs.image }}"
        echo "Digest: ${{ needs.build-and-push.outputs.digest }}"
        
        # Here you would typically deploy to your staging environment
        # For example, using docker-compose, kubectl, or cloud deployment tools
        
        # Example docker-compose deployment:
        cat > docker-compose.staging.yml << 'COMPOSE_EOF'
        version: '3.8'
        services:
          minecraft-bot:
            image: ${{ needs.build-and-push.outputs.image }}
            restart: unless-stopped
            environment:
              - NODE_ENV=staging
              - LOG_LEVEL=debug
            volumes:
              - ./config:/app/config:ro
              - ./logs:/app/logs:rw
            ports:
              - "3000:3000"
            healthcheck:
              test: ["CMD", "node", "-e", "console.log('OK')"]
              interval: 30s
              timeout: 10s
              retries: 3
              start_period: 60s
        COMPOSE_EOF
        
        echo "âœ… Staging deployment configuration created"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event.inputs.environment == 'production' || github.event_name == 'release'
    environment: production
    
    steps:
    - name: Deploy to production
      run: |
        echo "ðŸš€ Deploying to production environment..."
        echo "Image: ${{ needs.build-and-push.outputs.image }}"
        echo "Digest: ${{ needs.build-and-push.outputs.digest }}"
        
        # Production deployment configuration
        cat > docker-compose.production.yml << 'COMPOSE_EOF'
        version: '3.8'
        services:
          minecraft-bot:
            image: ${{ needs.build-and-push.outputs.image }}
            restart: always
            environment:
              - NODE_ENV=production
              - LOG_LEVEL=info
            volumes:
              - ./config:/app/config:ro
              - ./logs:/app/logs:rw
              - ./data:/app/data:rw
            ports:
              - "3000:3000"
            deploy:
              resources:
                limits:
                  memory: 512M
                  cpus: '0.5'
                reservations:
                  memory: 256M
                  cpus: '0.25'
            healthcheck:
              test: ["CMD", "node", "-e", "console.log('OK')"]
              interval: 30s
              timeout: 10s
              retries: 3
              start_period: 60s
            logging:
              driver: "json-file"
              options:
                max-size: "10m"
                max-file: "3"
        COMPOSE_EOF
        
        echo "âœ… Production deployment configuration created"
        
    - name: Create deployment summary
      run: |
        echo "## ðŸš€ Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Image**: \`${{ needs.build-and-push.outputs.image }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Digest**: \`${{ needs.build-and-push.outputs.digest }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: Production" >> $GITHUB_STEP_SUMMARY
        echo "- **Deployed at**: $(date -u)" >> $GITHUB_STEP_SUMMARY
